parser grammar SignatureParser;

// @header {
// package org.ucombinator.jade.classfile;
// }

options {
  tokenVocab = Ascii;
}

// Up to date for: JVMS 17

identifier: ~( '.' | ';' | '[' | '/' | '<' | '>' | ':' )+ ;

baseType
: 'B' # Byte
| 'C' # Char
| 'D' # Double
| 'F' # Float
| 'I' # Int
| 'J' # Long
| 'S' # Short
| 'Z' # Boolean
;

voidDescriptor
: 'V' # Void
;

////////////////////////////////////////////////////////////////
// Java type signature

javaTypeSignature
: referenceTypeSignature # JavaTypeReference
| baseType # JavaTypeBase
;

////////////////////////////////////////////////////////////////
// Reference type signature

referenceTypeSignature
: classTypeSignature # ReferenceTypeClass
| typeVariableSignature # ReferenceTypeVariable
| arrayTypeSignature # ReferenceTypeArray
;

classTypeSignature
: 'L' packageSpecifier? simpleClassTypeSignature classTypeSignatureSuffix* ';'
;

packageSpecifier
: identifier '/' packageSpecifier*
;

simpleClassTypeSignature
: identifier typeArguments?
;

typeArguments
: '<' typeArgument typeArgument* '>'
;

typeArgument
: wildcardIndicator? referenceTypeSignature # TypeArgumentNonStar
| '*' # TypeArgumentStar
;

wildcardIndicator
: '+' # WildcardPlus
| '-' # WildcardMinus
;

classTypeSignatureSuffix
: '.' simpleClassTypeSignature
;

typeVariableSignature
: 'T' identifier ';'
;

arrayTypeSignature
: '[' javaTypeSignature
;

////////////////////////////////////////////////////////////////
// Class signature

classSignature
: typeParameters? superclassSignature superinterfaceSignature*
;

typeParameters
: '<' typeParameter typeParameter* '>'
;

typeParameter
: identifier classBound interfaceBound*
;

classBound
: ':' referenceTypeSignature?
;

interfaceBound
: ':' referenceTypeSignature
;

superclassSignature
: classTypeSignature
;

superinterfaceSignature
: classTypeSignature
;

////////////////////////////////////////////////////////////////
// Method signature

methodSignature
: typeParameters? '(' javaTypeSignature* ')' result throwsSignature*
;

result
: javaTypeSignature # ResultNonVoid
| voidDescriptor # ResultVoid
;

throwsSignature
: '^' classTypeSignature # ThrowsClass
| '^' typeVariableSignature # ThrowsVariable
;

////////////////////////////////////////////////////////////////
// Field signature

fieldSignature
: referenceTypeSignature
;





















/*
grammar Signature;

// import com.github.javaparser.ast.type.*;

// Up to date for: JVMS 17

// The grammar includes the terminal symbol Identifier to denote the name of a type, field, method,
// formal parameter, local variable, or type variable, as generated by a Java compiler. Such a name
// must not contain any of the ASCII characters . ; [ / < > : (that is, the characters forbidden in
// method names (ยง4.2.2) and also colon) but may contain characters that must not appear in an
// identifier in the Java programming language (JLS ยง3.8).

Identifier: ~[.;[/<>:]+ ;

// BaseType:
//   (one of)
//   B C D F I J S Z
baseType returns [Type r]:
| 'B' { $r = PrimitiveType.byteType() }
| 'C' { $r = PrimitiveType.charType() }
| 'D' { $r = PrimitiveType.doubleType() }
| 'F' { $r = PrimitiveType.floatType() }
| 'I' { $r = PrimitiveType.intType() }
| 'J' { $r = PrimitiveType.longType() }
| 'S' { $r = PrimitiveType.shortType() }
| 'Z' { $r = PrimitiveType.booleanType() }
;

// VoidDescriptor:
//   V
voidDescriptor returns [VoidType r]:
| 'V' { $r = new VoidType() }
;

////////////////////////////////////////////////////////////////
// Java type signature

// JavaTypeSignature:
//   ReferenceTypeSignature
//   BaseType
javaTypeSignature returns [Type r]:
| e=referenceTypeSignature { $r = e }
| e=baseType { $r = e }
;

////////////////////////////////////////////////////////////////
// Reference type signature

// ReferenceTypeSignature:
//   ClassTypeSignature
//   TypeVariableSignature
//   ArrayTypeSignature
referenceTypeSignature returns [ReferenceType r]:
| e=classTypeSignature { $r = e }
| e=typeVariableSignature { $r = e }
| e=arrayTypeSignature { $r = e }
;

// ClassTypeSignature:
//   L [PackageSpecifier] SimpleClassTypeSignature {ClassTypeSignatureSuffix} ;
// returns ClassOrInterfaceType

// PackageSpecifier:
//   Identifier / {PackageSpecifier}

// SimpleClassTypeSignature:
//   Identifier [TypeArguments]

// TypeArguments:
//   < TypeArgument {TypeArgument} >

// TypeArgument:
//   [WildcardIndicator] ReferenceTypeSignature
//   *
typeArgument returns [Type r]:
| w=wildcardIndicator? r=referenceTypeSignature {
    if (w == null) { $r = r }
    else if (w == '+') { $r = new WildcardType(r) }
    else if (w == '-') { $r = new WildcardType(null, r) }
    else { fail; }
  }
| '*' { $r = new WildcardType(); }
;

// WildcardIndicator:
//   +
//   -
wildcardIndicator returns [char r]:
| e='+' { $r = e }
| e='-' { $r = e }
;

// ClassTypeSignatureSuffix:
//   . SimpleClassTypeSignature

// TypeVariableSignature:
//   T Identifier ;
typeVariableSignature returns [TypeParameter r]:
| 'T' Identifier ';' { $r = new TypeParameter($Identifier.text) }
;

// ArrayTypeSignature:
//   [ JavaTypeSignature
arrayTypeSignature returns [ArrayType r]:
| '[' e=javaTypeSignature { $r = new ArrayType(e) }
;


////////////////////////////////////////////////////////////////
// Class signature

// ClassSignature:
//   [TypeParameters] SuperclassSignature {SuperinterfaceSignature}

// TypeParameters:
//   < TypeParameter {TypeParameter} >

// TypeParameter:
//   Identifier ClassBound {InterfaceBound}

// ClassBound:
//   : [ReferenceTypeSignature]

// InterfaceBound:
//   : ReferenceTypeSignature

// SuperclassSignature:
//   ClassTypeSignature
superclassSignature returns [ClassOrInterfaceType r]:
| e=classTypeSignature { $r = e }
;

// SuperinterfaceSignature:
//   ClassTypeSignature
superinterfaceSignature returns [ClassOrInterfaceType r]:
| e=classTypeSignature { $r = e }
;


////////////////////////////////////////////////////////////////
// Method signature

// MethodSignature:
//   [TypeParameters] ( {JavaTypeSignature} ) Result {ThrowsSignature}

// Result:
//   JavaTypeSignature
//   VoidDescriptor
result returns [Type r]:
| e=javaTypeSignature { $r = e }
| e=voidDescriptor { $r = e }
;

// ThrowsSignature:
//   ^ ClassTypeSignature
//   ^ TypeVariableSignature
throwsSignature returns [ReferenceType r]: // TODO: more specific 'Type'
| '^' e=classTypeSignature { $r = e }
| '^' e=typeVariableSignature { $r = e }
;


////////////////////////////////////////////////////////////////
// Field signature

// FieldSignature:
//   ReferenceTypeSignature
fieldSignature returns [ReferenceType r]:
| e=referenceTypeSignature { $r = e }
;
*/