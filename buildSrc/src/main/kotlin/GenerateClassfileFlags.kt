package org.ucombinator.jade.gradle

import org.jsoup.Jsoup
// import org.jsoup.nodes.Element

// Code for generating `Flags.txt` and `Flags.kt`
object GenerateClassfileFlags {
  // def javaSpec(spec: String, version: Int, chapter: Int): String = {
  //   if (version < 9) {
  //     throw new Exception(f"The specified version must be at least 9, but version is ${version}.")
  //   }
  //   val url = f"https://docs.oracle.com/javase/specs/${spec}/se${version}/html/${spec}-${chapter}.html"
  //   val source: scala.io.Source =
  //     try {
  //       scala.io.Source.fromURL(url)
  //     } catch {
  //       case e: Throwable => throw new Exception(f"Download of java specification failed", e)
  //     }
  //   val string = source.mkString
  //   source.close()
  //   string
  // }

  fun table(html: String): String {
    // val builder = StringBuilder.newBuilder
    val document = Jsoup.parse(html)

    // builder.append(f"""# Do not edit this file by hand.  It is generated by `sbt flagsTable`.
    //                   |
    //                   |# Kind      Name             Value  Keyword      Description
    //                   |""".trimMargin)

    // val tables = List[(String, String)](
    //   "Class" -> "Class access and property modifiers",
    //   "Field" -> "Field access and property flags",
    //   "Method" -> "Method access and property flags",
    //   "NestedClass" -> "Nested class access and property flags",
    // )
    // for ((kind, tableSummary) <- tables) {
    //   val mutable.Buffer(table) = document.select(f"""table[summary="${tableSummary}"]""").asScala
    //   for (row <- table.select("tbody > tr").asScala.toList) {
    //     val List(accName, value, description) = row.select("td").asScala.toList
    //     val keywordOption = """(Declared|Marked|Marked or implicitly) <code class="literal">(.*)</code>""".r
    //       .findFirstMatchIn(description.childNodes().asScala.mkString)
    //     val keyword = keywordOption match {
    //       case Some(regexMatch) => regexMatch.group(2)
    //       case None => "-"
    //     }
    //     builder.append(f"${kind}%-11s ${accName.text}%-16s ${value.text} ${keyword}%-12s ${description.text}\n")
    //   }
    //   builder.append("\n")
    // }

    // val lists = List[(String, String)](
    //   "Parameter" -> "access_flags",
    //   "Module" -> "module_flags",
    //   "Requires" -> "requires_flags",
    //   "Exports" -> "exports_flags",
    //   "Opens" -> "opens_flags",
    // )
    // for ((kind, codeLiteral) <- lists) {
    //   val mutable.Buffer(list) = document
    //     .select(
    //       f"dd:has(div[class=variablelist] dl) > p:matchesOwn(The value of the) > code[class=literal]:matchesOwn(^${codeLiteral}$$)"
    //     )
    //     .asScala
    //   val rows = list.parent.nextElementSibling.child(0).children().asScala.grouped(2)
    //   for (mutable.Buffer(row: Element, description: Element) <- rows.toList) {
    //     val regexMatch = """(0x[0-9]*) \(([A-Z_]*)\)""".r.findPrefixMatchOf(row.text).get
    //     val value = regexMatch.group(1)
    //     val accName = regexMatch.group(2)
    //     val keyword =
    //       if (accName == "ACC_TRANSITIVE") { "transitive" }
    //       else { "-" }
    //     builder.append(f"${kind}%-11s ${accName}%-16s ${value} ${keyword}%-12s ${description.text}\n")
    //   }
    //   builder.append("\n")
    // }

    // builder.mkString.replaceAll("\n\n$", "\n")
    return "TODO"
  }

  private data class FlagInfo(
    val kind: String,
    val accName: String,
    val value: Int,
    val keyword: String?,
    val description: String
  )

  fun code(table: String): String {
    val flagInfos = table
      .lines()
      .filter { !it.matches("\\s*#.*".toRegex()) }
      .filter { !it.matches("\\s*".toRegex()) }
      .map {
        val (kind, accName, value, keyword, description) = it.split(" +".toRegex(), 5)
        val k = if (keyword == "-") { null } else { keyword }
        val intValue = value.substring(2).toInt(16)
        FlagInfo(kind, accName, intValue, k, description)
      }

    val flagInfoMap = flagInfos.groupBy { it.accName }
    val flagExtensions = flagInfoMap.mapValues { it.value.map { it.kind } }
    val uniqueFlagInfos = flagInfoMap.toList().map { it.second.first() }.sortedBy { it.accName }.sortedBy { it.value }
    val flagInfoGroups = hashMapOf<String, List<FlagInfo>>()
    for (m in flagInfos) {
      flagInfoGroups.put(m.kind, flagInfoGroups.getOrDefault(m.kind, listOf()).plus(m))
    }

    val builder = StringBuilder()

    builder.append(
      """// Do not edit this file by hand.  It is generated by `gradle`.
        |
        |package org.ucombinator.jade.classfile
        |
        |import com.github.javaparser.ast.Modifier
        |import com.github.javaparser.ast.NodeList
        |
        |sealed interface Flag {
        |  fun value(): Int
        |  fun valueAsString(): String = "0x${'$'}{"%04x".format(value())}"
        |  fun keyword(): Modifier.Keyword?
        |  fun modifier(): Modifier? = if (keyword() === null) { null } else { Modifier(keyword()) }
        |}
        |
        |
      """.trimMargin()
    )

    for (kind in flagInfos.map { it.kind }.distinct()) {
      builder.append("sealed interface ${kind}Flag : Flag\n")
    }

    builder.append(
      """
        |object Flags {
        |  fun toModifiers(flags: List<Flag>): NodeList<Modifier> =
        |    NodeList(flags.mapNotNull { it.modifier() })
        |
        |  private fun <T> fromInt(mapping: List<Pair<Int, T>>): (Int) -> List<T> = { int ->
        |    val maskedInt = int and 0xffff // Ignore ASM specific flags, which occur above bit 16
        |    val result = mapping.filter { it.first and maskedInt != 0 }
        |    val intResult = result.fold(0) { x, y -> x or y.first }
        |    assert(maskedInt == intResult, { "flag parsing error: want 0x${'$'}{"%x".format(int)}, got 0x${'$'}{"%x".format(intResult)}" })
        |    result.map { it.second }
        |  }
        |
        |
      """.trimMargin()
    )

    for (flagsInfo in uniqueFlagInfos) {
      val keyword = if (flagsInfo.keyword === null) { null } else { "Modifier.Keyword.${flagsInfo.keyword.toUpperCase()}" }
      val extensions = flagExtensions.getValue(flagsInfo.accName).joinToString(", ") { "${it}Flag" }

      builder.append(
        """  object ${flagsInfo.accName} : Flag, $extensions {
          |    override fun value() = 0x${"%04x".format(flagsInfo.value)}
          |    override fun keyword() = $keyword
          |  }
          |
        """.trimMargin()
      )
    }

    for ((kind, flagInfosForKind) in flagInfoGroups) {
      assert(flagInfosForKind.map { it.value } == flagInfosForKind.map { it.value }.distinct())
      builder.append("  private val ${kind}Mapping = listOf<Pair<Int, ${kind}Flag>>(\n")
      for (flagInfo in flagInfosForKind.sortedBy { it.value }) {
        builder.append(
          "    Pair( /*0x${"%04x".format(flagInfo.value)}*/ ${flagInfo.accName}.value(), ${flagInfo.accName}), // ${flagInfo.description}\n"
        )
      }
      builder.append("  )\n")
    }
    builder.append("\n")

    for ((kind, flagInfosForKind) in flagInfoGroups) {
      val name = "${kind.substring(0, 1).toLowerCase()}${kind.substring(1)}Flags"
      builder.append("  val $name: (Int) -> List<${kind}Flag> = fromInt(${kind}Mapping)\n")
    }
    builder.append("}\n")

    return builder.toString()
  }
}
